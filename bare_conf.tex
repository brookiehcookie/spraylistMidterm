
%% bare_conf.tex
%% V1.4b
%% 2015/08/26
%% by Michael Shell
%% See:
%% http://www.michaelshell.org/
%% for current contact information.
%%
%% This is a skeleton file demonstrating the use of IEEEtran.cls
%% (requires IEEEtran.cls version 1.8b or later) with an IEEE
%% conference paper.
%%
%% Support sites:
%% http://www.michaelshell.org/tex/ieeetran/
%% http://www.ctan.org/pkg/ieeetran
%% and
%% http://www.ieee.org/

%%*************************************************************************
%% Legal Notice:
%% This code is offered as-is without any warranty either expressed or
%% implied; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE! 
%% User assumes all risk.
%% In no event shall the IEEE or any contributor to this code be liable for
%% any damages or losses, including, but not limited to, incidental,
%% consequential, or any other damages, resulting from the use or misuse
%% of any information contained here.
%%
%% All comments are the opinions of their respective authors and are not
%% necessarily endorsed by the IEEE.
%%
%% This work is distributed under the LaTeX Project Public License (LPPL)
%% ( http://www.latex-project.org/ ) version 1.3, and may be freely used,
%% distributed and modified. A copy of the LPPL, version 1.3, is included
%% in the base LaTeX documentation of all distributions of LaTeX released
%% 2003/12/01 or later.
%% Retain all contribution notices and credits.
%% ** Modified files should be clearly indicated as such, including  **
%% ** renaming them and changing author support contact information. **
%%*************************************************************************


% *** Authors should verify (and, if needed, correct) their LaTeX system  ***
% *** with the testflow diagnostic prior to trusting their LaTeX platform ***
% *** with production work. The IEEE's font choices and paper sizes can   ***
% *** trigger bugs that do not appear when using other class files.       ***                          ***
% The testflow support page is at:
% http://www.michaelshell.org/tex/testflow/



\documentclass[conference]{IEEEtran}
% Some Computer Society conferences also require the compsoc mode option,
% but others use the standard conference format.
%
% If IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it like:
% \documentclass[conference]{../sty/IEEEtran}





% Some very useful LaTeX packages include:
% (uncomment the ones you want to load)


% *** MISC UTILITY PACKAGES ***
%
%\usepackage{ifpdf}
% Heiko Oberdiek's ifpdf.sty is very useful if you need conditional
% compilation based on whether the output is pdf or dvi.
% usage:
% \ifpdf
%   % pdf code
% \else
%   % dvi code
% \fi
% The latest version of ifpdf.sty can be obtained from:
% http://www.ctan.org/pkg/ifpdf
% Also, note that IEEEtran.cls V1.7 and later provides a builtin
% \ifCLASSINFOpdf conditional that works the same way.
% When switching from latex to pdflatex and vice-versa, the compiler may
% have to be run twice to clear warning/error messages.






% *** CITATION PACKAGES ***
%
%\usepackage{cite}
% cite.sty was written by Donald Arseneau
% V1.6 and later of IEEEtran pre-defines the format of the cite.sty package
% \cite{} output to follow that of the IEEE. Loading the cite package will
% result in citation numbers being automatically sorted and properly
% "compressed/ranged". e.g., [1], [9], [2], [7], [5], [6] without using
% cite.sty will become [1], [2], [5]--[7], [9] using cite.sty. cite.sty's
% \cite will automatically add leading space, if needed. Use cite.sty's
% noadjust option (cite.sty V3.8 and later) if you want to turn this off
% such as if a citation ever needs to be enclosed in parenthesis.
% cite.sty is already installed on most LaTeX systems. Be sure and use
% version 5.0 (2009-03-20) and later if using hyperref.sty.
% The latest version can be obtained at:
% http://www.ctan.org/pkg/cite
% The documentation is contained in the cite.sty file itself.






% *** GRAPHICS RELATED PACKAGES ***
%
\ifCLASSINFOpdf
  % \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  % \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi
% graphicx was written by David Carlisle and Sebastian Rahtz. It is
% required if you want graphics, photos, etc. graphicx.sty is already
% installed on most LaTeX systems. The latest version and documentation
% can be obtained at: 
% http://www.ctan.org/pkg/graphicx
% Another good source of documentation is "Using Imported Graphics in
% LaTeX2e" by Keith Reckdahl which can be found at:
% http://www.ctan.org/pkg/epslatex
%
% latex, and pdflatex in dvi mode, support graphics in encapsulated
% postscript (.eps) format. pdflatex in pdf mode supports graphics
% in .pdf, .jpeg, .png and .mps (metapost) formats. Users should ensure
% that all non-photo figures use a vector format (.eps, .pdf, .mps) and
% not a bitmapped formats (.jpeg, .png). The IEEE frowns on bitmapped formats
% which can result in "jaggedy"/blurry rendering of lines and letters as
% well as large increases in file sizes.
%
% You can find documentation about the pdfTeX application at:
% http://www.tug.org/applications/pdftex



% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}

\title{Implementing a SprayList}


\author{\IEEEauthorblockN{Brooke Cochenour}
\IEEEauthorblockA{University of Central Florida Student}
\and
\IEEEauthorblockN{Alexander McKeel}
\IEEEauthorblockA{University of Central Florida Student}
\and
\IEEEauthorblockN{Harrison Geiger}
\IEEEauthorblockA{University of Central Florida Student}}




% make the title area
\maketitle

% As a general rule, do not put math, special symbols or citations
% in the abstract
\begin{abstract}
The SprayList is a scalable relaxed priority queue with a SkipList foundation that does not have the same restrictions as alternative algorithms when it comes to scalability.  The SprayList is designed to be able to handle a high number of threads, unlike its alternative algorithms . Following the research paper written by Nir Shavit et. al. The SprayList: A Scalable Relaxed Priority Queue, we have created an implementation of the SprayList in C++. This research paper provided a variety of pseudocode, proofs, and testing results that assisted with creating our implementation of the SprayList. We approached this implementation through first constructing a lock-free SkipList. After the SkipList was fully functioning, we began to implement the additional optimizations that improve upon the scalability of the SprayList. Our team implemented two different versions of the SprayList: concurrent and transactional. In this paper you will find more in depth detail about each implementation version, how they compare to alternatives, and their optimizations following the SprayList guidelines first introduced by Shavit et. al.
\end{abstract}

\IEEEpeerreviewmaketitle



\section{SprayList’s Purpose}

The purpose of the SprayList is to provide an algorithm that does not have the sequential bottleneck of capping the number of threads to single digit numbers like alternative algorithms do [1]. In some instances, a FIFO queue is not strictly necessary as for many use cases, the highest priority element in a priority queue is not needed. The SprayList algorithm allows for a random range of the high-priority nodes to be removed.

Shavit et al. explains that existing algorithms (at least, at the time) with stricter rules have issues of high contention and, as mentioned above, low scalability [2]. This algorithm alleviates this[2].

\section{General Design Decisions}
Our code implementation is intended to follow the design laid out by  “The SprayList…”. by Shavit et. al. The authors themselves also reference The Art of Multiprocessor Programming by Maurice Herlihy and Nir Shavit [2], which we found of use. 

The authors explain that their algorithm is Skip-List based;  naturally, we too implemented a form of a SkipList.  As a reference, we followed pseudocode from The Art of Multiprocessor Programming associated with a few different SkipList implementations [2].  We chose C++ as there are many advantages to writing concurrent code using C++ such as the ability to create templates that have been very helpful throughout the implementation of the SkipList foundation for the SprayList.


\section{Progress Guarantees}
SprayLists provide several progress guarantees. SprayLists are lock-free and because of this deadlocks should not happen if the SprayList has been correctly implemented [1]. This keeps each thread progressing and making progress towards its assigned task.  Another progress guarantee SprayLists provide is the fact that, according to the author, the data structure has a starvation-free design when it comes to nodes that have higher priorities [1]. This means that nodes of higher priority will not starve those of lower priority allowing each node to make progress towards it goal [1]. SprayList are also said to be wait-free,which is another factor that assists in keeping threads making progress towards completing their goals. 

\section {Correctness Condition}

SprayList was not designed to resemble a strict FIFO queue, however, even though it does not emulate a FIFO queue it is very similar in a variety of ways such as the way that it comes close to dequing the first node inserted before the ones inserted after that first node, however, this is not always the case [1]. The SprayList algorithm “guarantees an even selection among the first polylog p elements in the SkipList” [1].


The SprayList is linearizable partially due to the fact that it is composed of a lock-free SkipList [1]. The linearizability points match those of the lock-free SkipList that makes up the SprayList.


\section {Synchronization Techniques}

C++  does not have Atomic Markable References like Java does. Due to this, our team created an AtomicMarkableReference class in order to promote synchronization throughout the threads. This was implemented through using the C++ atomic atomic of type uintptr\_t  and setting the least-significant-bit of this atomic pointer to be the mark for the reference.


To assist with synchronization, there a variety of linearization points throughout the SprayList [1]. These points correlate to those of a lock-free SkipList, whose methods make up the majority of the SprayList.

\section {SkipList Algorithms}

our implemented functions that can be found in our code are the add (adding a value into the skiplist), remove(remove a node - note that this method is called delete in The Art of Multiprocessor Programming), find, and contains (check if a node exists) functions [2]. These 4 algorithms are present in the The Art of Multiprocessor Programming as pseudocode and combined offer essential functionality for SkipList traversal.


\section {SprayList Versus Alternatives}

There are many advantages of using spraylist versus its alternatives. To start, There are a variety of experiments that show that the SprayList data structure has a highly scalable thread count due to relaxed semantic [1]. This is important because its alternatives, such as an unordered skiplist, do not have this kind of scalability and are limited to single digit thread numbers performance wise. SprayList uses a DELETE\_MIN method that is very innovative and allows the SprayList to past the sequential bottleneck of alternatives [1]. This sequential bottleneck, for alternatives, keeps threads from scaling pass a max number in the single digits [1]. However, through the innovation demonstrated in the SprayList DELETE\_MIN method where the method “returns an element among the first p log\textsuperscript{3}p nodes in the list where p is the number of threads” this is not an issue as the runtime is independent of the list size and the sequential bottleneck of alternative data structures can be surpassed [1]. There are many implementations of alternative data structures that have attempted to eliminate or reduce the bottleneck that comes from the DELETE\_MIN operation, however, with the reductions came a multitude of compare and swaps which lead to the alternatives not being able to handle high-contention workloads with a high thread count [1]. An example of such an alternative, would be Lindén and Jonsson’s implementation of a SkipList, their implementation successfully reduced the bottle neck of the DELETE\_MIN operation, however, the compare and swap operations that were used to reduce said bottleneck resulted in high contention. 

According to Nir Shavit et. al, SprayLists can provide “fully scalable throughput for up to 80 concurrent threads under high-contention workloads”, while competing alternative data structures “suffer from very high contention under a standard workload” [1]. The alternative data structures suffer due to the fact threads are still completing frequently for critical sections which places a limit on the amount of workload the threads can deal with along with the amount of threads that the data structure can support [1]. 

There are alternative implementations of data structures, such as the implementation of the lock-free priority queue by Wimmer et. al., which has a better system for semantics than the SprayList [1].. However, these type of alternatives come with a synchronization cost which is much higher than that of the SprayList [1]. While the SprayList may not have the best way to handle ordering semantics, it does not have the synchronization cost that many of those alternatives present [1].

Another advantage of the SprayList data structure is the fact that it can provide “probabilistic guarantees on the relative priority of returned elements, and on the running time of operations.” [1]. Due to these guarantees, the SprayList set apart from its alternatives who can not always guarantee the running time of an operation. 

\section{SprayList Optimizations}
There are a variety of optimizations the SprayList provides that help improve the overall performance of the data structure.

\subsection{Padding}

Padding is used in a SprayList in order to ensure that the first couple of elements present in the list are not treated unfairly [1]. The padding happens in the beginning of the skiplist where K(p) dummy entries are placed where p is the number of threads [1].

\subsection{Cleaners}
Cleaners in SprayList are considered a way to optimize the data structure as they are not needed in a SprayList implementation, however, can prove to be very useful [1]. In order for cleaners to perform their jobs, there first must be threads who become cleaners. The threads who become cleaners are decided through a coin flip (1/p) where p is the number of threads [1]. If the coin flip is successful and a thread has become a cleaner, there are several jobs a cleaner is responsible for. To start off, a cleaner searches the bottom-level list of a SkipList linearly in order to find a key it needs to acquire so that it can execute the lock-free version of DELETE\_MIN implementation by Lotan-Shavit [1]. The next job a cleaner thread is responsible for is adjusting pointers to nodes that have already been acquired previously by the spray operations of the SprayList.

\subsection{Contention Adaptation}

The SprayList, based on the contention level, will allow threads to adjust spray parameters dynamically [1]. This is an important optimization as it allows a thread to estimate the number of threads needed and then if contention is detected to be higher than what the thread had previously estimated, the thread can then increase its estimated number of threads in order to accommodate the greater contention [1]. While this sort of adaptation to contention can optimize performance greatly, when implemented, it will dequeue an element with the smallest key if there is only a single thread accessing the SprayList [1].




\begin{thebibliography}{1}
	


\bibitem{IEEEhowto:kopka}
Herlihy, Maurice and Shavit, Nir, \emph{The Art of Multiprocessor Programming}\hskip 1em plus
  0.5em minus 0.4em\relax San Francisco, CA, USA: Morgan Kaufmann Publishers Inc., 2008. SHOULD BE RESEARCH PAPER
  
\bibitem{IEEEhowto:kopka}
Herlihy, Maurice and Shavit, Nir, \emph{The Art of Multiprocessor Programming}\hskip 1em plus
0.5em minus 0.4em\relax San Francisco, CA, USA: Morgan Kaufmann Publishers Inc., 2008.
  
\bibitem{IEEEhowto:kopka}
Fraser, Keir \emph{Practical lock-freedom}\hskip 1em plus
0.5em minus 0.4em\relax  2004.




\end{thebibliography}




% that's all folks
\end{document}

\pdflatex output
